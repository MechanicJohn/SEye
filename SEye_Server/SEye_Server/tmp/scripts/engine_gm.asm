; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\Admin\Desktop\Projects\SEye_Server\engine_gm.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	??A?$SimpleVecClass@PAVGameObjObserverClass@@@@QAEAAPAVGameObjObserverClass@@H@Z ; SimpleVecClass<GameObjObserverClass *>::operator[]
PUBLIC	?Count@?$SimpleDynVecClass@PAVGameObjObserverClass@@@@QAEHXZ ; SimpleDynVecClass<GameObjObserverClass *>::Count
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z	; std::char_traits<char>::_Move_s
PUBLIC	??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::move_s<std::char_traits<char> >
PUBLIC	??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::move_s<std::char_traits<char> >
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ; std::_Char_traits_cat<std::char_traits<char> >
PUBLIC	?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z	; std::char_traits<char>::_Copy_s
PUBLIC	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
PUBLIC	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?Peek_Buffer@WideStringClass@@QAEPA_WXZ		; WideStringClass::Peek_Buffer
PUBLIC	??A?$VectorClass@PAVWeaponClass@@@@QAEAAPAVWeaponClass@@H@Z ; VectorClass<WeaponClass *>::operator[]
PUBLIC	?Count@?$DynamicVectorClass@PAVWeaponClass@@@@QAEHXZ ; DynamicVectorClass<WeaponClass *>::Count
PUBLIC	??0StringClass@@QAE@XZ				; StringClass::StringClass
PUBLIC	?Add@?$DynamicVectorClass@VStringClass@@@@QAE_NAAVStringClass@@@Z ; DynamicVectorClass<StringClass>::Add
PUBLIC	?ObjectsFile@@3PADA				; ObjectsFile
PUBLIC	?Get_First_Definition@@3P6APAVDefinitionClass@@KD@ZA ; Get_First_Definition
PUBLIC	?Get_Next_Definition@@3P6APAVDefinitionClass@@PAV1@KD@ZA ; Get_Next_Definition
PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BH@GPONABH@MDB_SSGM_Vehicle_Owner?$AA@	; `string'
PUBLIC	??_C@_02OLOABKKD@ID?$AA@			; `string'
PUBLIC	??_C@_0L@DPPAAEEC@MDB_New_C4?$AA@		; `string'
PUBLIC	??_C@_0DN@JLFMABPJ@ppage?5?$CFd?5Remote?3?5?$CFd?5?5?9?5Proximity@ ; `string'
PUBLIC	??_C@_11LOCGONAA@?$AA?$AA@			; `string'
PUBLIC	??_C@_04OHJIHAFH@None?$AA@			; `string'
PUBLIC	??_C@_19KLMLHLJG@?$AAN?$AAo?$AAn?$AAe?$AA?$AA@	; `string'
PUBLIC	??_C@_1BA@KKAIEBA@?$AAN?$AAe?$AAu?$AAt?$AAr?$AAa?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@PJAIDCO@?$AAN?$AAo?$AA?5?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@ ; `string'
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
EXTRN	_stricmp:PROC
EXTRN	_wcstombs:PROC
EXTRN	?_Xran@_String_base@std@@SAXXZ:PROC		; std::_String_base::_Xran
EXTRN	_memmove_s:PROC
EXTRN	?_Xlen@_String_base@std@@SAXXZ:PROC		; std::_String_base::_Xlen
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	_memcpy_s:PROC
	ALIGN	4

?ObjectsFile@@3PADA DD 01H DUP (?)			; ObjectsFile
?Get_First_Definition@@3P6APAVDefinitionClass@@KD@ZA DD 01H DUP (?) ; Get_First_Definition
?Get_Next_Definition@@3P6APAVDefinitionClass@@PAV1@KD@ZA DD 01H DUP (?) ; Get_Next_Definition
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST	ENDS
;	COMDAT ??_C@_1BE@PJAIDCO@?$AAN?$AAo?$AA?5?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@PJAIDCO@?$AAN?$AAo?$AA?5?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@ DB 'N'
	DB	00H, 'o', 00H, ' ', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@KKAIEBA@?$AAN?$AAe?$AAu?$AAt?$AAr?$AAa?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@KKAIEBA@?$AAN?$AAe?$AAu?$AAt?$AAr?$AAa?$AAl?$AA?$AA@ DB 'N', 00H
	DB	'e', 00H, 'u', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'l', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_19KLMLHLJG@?$AAN?$AAo?$AAn?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_19KLMLHLJG@?$AAN?$AAo?$AAn?$AAe?$AA?$AA@ DB 'N', 00H, 'o', 00H, 'n', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHJIHAFH@None?$AA@
CONST	SEGMENT
??_C@_04OHJIHAFH@None?$AA@ DB 'None', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_11LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@JLFMABPJ@ppage?5?$CFd?5Remote?3?5?$CFd?5?5?9?5Proximity@
CONST	SEGMENT
??_C@_0DN@JLFMABPJ@ppage?5?$CFd?5Remote?3?5?$CFd?5?5?9?5Proximity@ DB 'pp'
	DB	'age %d Remote: %d  - Proximity: %d - Total: %d - Limit: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DPPAAEEC@MDB_New_C4?$AA@
CONST	SEGMENT
??_C@_0L@DPPAAEEC@MDB_New_C4?$AA@ DB 'MDB_New_C4', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02OLOABKKD@ID?$AA@
CONST	SEGMENT
??_C@_02OLOABKKD@ID?$AA@ DB 'ID', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GPONABH@MDB_SSGM_Vehicle_Owner?$AA@
CONST	SEGMENT
??_C@_0BH@GPONABH@MDB_SSGM_Vehicle_Owner?$AA@ DB 'MDB_SSGM_Vehicle_Owner', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
;	COMDAT ??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ
_TEXT	SEGMENT
__Secure$ = -1						; size = 1
??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ PROC ; std::_Char_traits_cat<std::char_traits<char> >, COMDAT

; 575  : 	{

	push	ecx

; 576  : 		typename _Char_traits_category<_Traits>::_Secure_char_traits _Secure;
; 577  : 		return (_Secure);

	mov	al, BYTE PTR __Secure$[esp+4]

; 578  : 	}

	pop	ecx
	ret	0
??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ENDP ; std::_Char_traits_cat<std::char_traits<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	or	eax, -1

; 167  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1671 : 		size_type _Num = _Mybase::_Alval.max_size();
; 1672 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 1673 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	DWORD PTR ?RenDelete@@3P6AXPAX@ZA	; RenDelete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2170 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx+4]

; 2171 : 		}

	ret	0
$LN3@Myptr:

; 2170 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	lea	eax, DWORD PTR [ecx+4]

; 2171 : 		}

	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2133 : 		{	// test if _Ptr points inside string

	push	esi
	push	edi

; 2134 : 		if (_Ptr == 0 || _Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

	mov	edi, DWORD PTR __Ptr$[esp+4]
	test	edi, edi
	je	SHORT $LN2@Inside
	mov	esi, DWORD PTR [ecx+24]
	lea	eax, DWORD PTR [ecx+4]
	cmp	esi, 16					; 00000010H
	jb	SHORT $LN8@Inside
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN9@Inside
$LN8@Inside:
	mov	edx, eax
$LN9@Inside:
	cmp	edi, edx
	jb	SHORT $LN2@Inside
	cmp	esi, 16					; 00000010H
	jb	SHORT $LN12@Inside
	mov	eax, DWORD PTR [eax]
$LN12@Inside:
	mov	ecx, DWORD PTR [ecx+20]
	add	ecx, eax
	cmp	ecx, edi
	jbe	SHORT $LN2@Inside
	pop	edi

; 2136 : 		else
; 2137 : 			return (true);

	mov	al, 1
	pop	esi

; 2138 : 		}

	ret	4
$LN2@Inside:
	pop	edi

; 2135 : 			return (false);	// don't ask

	xor	al, al
	pop	esi

; 2138 : 		}

	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 478  : 		{	// copy constructor

	mov	eax, ecx

; 479  : #if defined(_DEBUG)
; 480  : 		if (_Right._Myfirstiter == _IGNORE_MYITERLIST)
; 481  : 			{
; 482  : 			this->_Myfirstiter = _IGNORE_MYITERLIST;
; 483  : 			}
; 484  : #endif
; 485  : 		}

	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 472  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 473  : 		}

	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2175 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $LN3@Myptr@2
	mov	eax, DWORD PTR [ecx+4]

; 2176 : 		}

	ret	0
$LN3@Myptr@2:

; 2175 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	lea	eax, DWORD PTR [ecx+4]

; 2176 : 		}

	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1666 : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx+20]

; 1667 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1651 : 		return (_Myptr());

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $LN5@c_str
	mov	eax, DWORD PTR [ecx+4]

; 1652 : 		}

	ret	0

; 1651 : 		return (_Myptr());

$LN5@c_str:
	lea	eax, DWORD PTR [ecx+4]

; 1652 : 		}

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Ogtpy
; File c:\users\admin\desktop\projects\seye_server\engine_vector.h
_TEXT	ENDS
;	COMDAT ??A?$SimpleVecClass@PAVGameObjObserverClass@@@@QAEAAPAVGameObjObserverClass@@H@Z
_TEXT	SEGMENT
??A?$SimpleVecClass@PAVGameObjObserverClass@@@@QAEAAPAVGameObjObserverClass@@H@Z PROC ; SimpleVecClass<GameObjObserverClass *>::operator[], COMDAT
; _this$ = eax
; _index$ = edx

; 185  : 		return Vector[index];

	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+edx*4]

; 186  : 	}

	ret	0
??A?$SimpleVecClass@PAVGameObjObserverClass@@@@QAEAAPAVGameObjObserverClass@@H@Z ENDP ; SimpleVecClass<GameObjObserverClass *>::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Count@?$SimpleDynVecClass@PAVGameObjObserverClass@@@@QAEHXZ
_TEXT	SEGMENT
?Count@?$SimpleDynVecClass@PAVGameObjObserverClass@@@@QAEHXZ PROC ; SimpleDynVecClass<GameObjObserverClass *>::Count, COMDAT
; _this$ = eax

; 268  : 		return ActiveCount;

	mov	eax, DWORD PTR [eax+12]

; 269  : 	}

	ret	0
?Count@?$SimpleDynVecClass@PAVGameObjObserverClass@@@@QAEHXZ ENDP ; SimpleDynVecClass<GameObjObserverClass *>::Count
_TEXT	ENDS
PUBLIC	?InitEngineSSGM@@YAXXZ				; InitEngineSSGM
; Function compile flags: /Ogtpy
; File c:\users\admin\desktop\projects\seye_server\engine_gm.cpp
;	COMDAT ?InitEngineSSGM@@YAXXZ
_TEXT	SEGMENT
?InitEngineSSGM@@YAXXZ PROC				; InitEngineSSGM, COMDAT

; 28   : 	switch (Exe) {

	mov	eax, DWORD PTR ?Exe@@3HA		; Exe
	sub	eax, 1
	je	SHORT $LN4@InitEngine@16
	sub	eax, 1
	je	SHORT $LN3@InitEngine@16
	sub	eax, 1
	jne	SHORT $LN5@InitEngine@16

; 39   : 		}
; 40   : 		break;
; 41   : 	case 3: { //RH8
; 42   : 			Get_First_Definition = (GetFirstDefinition)0x08318DD0;

	mov	DWORD PTR ?Get_First_Definition@@3P6APAVDefinitionClass@@KD@ZA, 137465296 ; Get_First_Definition, 08318dd0H

; 43   : 			Get_Next_Definition = (GetNextDefinition)0x08318E5A;

	mov	DWORD PTR ?Get_Next_Definition@@3P6APAVDefinitionClass@@PAV1@KD@ZA, 137465434 ; Get_Next_Definition, 08318e5aH

; 44   : 			ObjectsFile = (char*)0x0850CCAE;

	mov	DWORD PTR ?ObjectsFile@@3PADA, 139513006 ; ObjectsFile, 0850ccaeH

; 45   : 		}
; 46   : 		break;
; 47   : 	default: {
; 48   : 		}
; 49   : 		break;
; 50   : 	}
; 51   : }

	ret	0
$LN3@InitEngine@16:

; 33   : 		}
; 34   : 		break;
; 35   : 	case 2: { //RH73
; 36   : 			Get_First_Definition = (GetFirstDefinition)0x08365FD4;

	mov	DWORD PTR ?Get_First_Definition@@3P6APAVDefinitionClass@@KD@ZA, 137781204 ; Get_First_Definition, 08365fd4H

; 37   : 			Get_Next_Definition = (GetNextDefinition)0x08366064;

	mov	DWORD PTR ?Get_Next_Definition@@3P6APAVDefinitionClass@@PAV1@KD@ZA, 137781348 ; Get_Next_Definition, 08366064H

; 38   : 			ObjectsFile = (char*)0x08624DC8;

	mov	DWORD PTR ?ObjectsFile@@3PADA, 140660168 ; ObjectsFile, 08624dc8H

; 45   : 		}
; 46   : 		break;
; 47   : 	default: {
; 48   : 		}
; 49   : 		break;
; 50   : 	}
; 51   : }

	ret	0
$LN4@InitEngine@16:

; 29   : 	case 1: { //server.dat
; 30   : 			Get_First_Definition = (GetFirstDefinition)0x00526540;

	mov	DWORD PTR ?Get_First_Definition@@3P6APAVDefinitionClass@@KD@ZA, 5399872 ; Get_First_Definition, 00526540H

; 31   : 			Get_Next_Definition = (GetNextDefinition)0x005265B0;

	mov	DWORD PTR ?Get_Next_Definition@@3P6APAVDefinitionClass@@PAV1@KD@ZA, 5399984 ; Get_Next_Definition, 005265b0H

; 32   : 			ObjectsFile = (char*)0x008110EC;

	mov	DWORD PTR ?ObjectsFile@@3PADA, 8458476	; ObjectsFile, 008110ecH
$LN5@InitEngine@16:

; 45   : 		}
; 46   : 		break;
; 47   : 	default: {
; 48   : 		}
; 49   : 		break;
; 50   : 	}
; 51   : }

	ret	0
?InitEngineSSGM@@YAXXZ ENDP				; InitEngineSSGM
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size_in_bytes$ = 12					; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z PROC	; std::char_traits<char>::_Move_s, COMDAT

; 487  : //		_DEBUG_POINTER(_First1);
; 488  : //		_DEBUG_POINTER(_First2);
; 489  : 		_CRT_SECURE_MEMMOVE(_First1, _Size_in_bytes, _First2, _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size_in_bytes$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H

; 490  : 		return _First1;

	mov	eax, esi
	pop	esi

; 491  : 		}

	ret	0
?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z ENDP	; std::char_traits<char>::_Move_s
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size_in_bytes$ = 12					; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z PROC	; std::char_traits<char>::_Copy_s, COMDAT

; 463  : //		_DEBUG_POINTER(_First1);
; 464  : //		_DEBUG_POINTER(_First2);
; 465  : 		_CRT_SECURE_MEMCPY(_First1, _Size_in_bytes, _First2, _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size_in_bytes$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 466  : 		return _First1;

	mov	eax, esi
	pop	esi

; 467  : 		}

	ret	0
?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z ENDP	; std::char_traits<char>::_Copy_s
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 448  : //		_DEBUG_POINTER(_First);
; 449  : 		return (::strlen(_First));

	mov	eax, DWORD PTR __First$[esp-4]
	lea	edx, DWORD PTR [eax+1]
$LL3@length:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL3@length
	sub	eax, edx

; 450  : 		}

	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 425  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	cl, BYTE PTR [eax]
	mov	edx, DWORD PTR __Left$[esp-4]
	mov	BYTE PTR [edx], cl

; 426  : 		}

	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
;	COMDAT ??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
___formal$ = 24						; size = 1
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z PROC ; std::_Traits_helper::move_s<std::char_traits<char> >, COMDAT

; 624  : 		return _Traits::_Move_s(_First1, _Size, _First2, _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
	mov	eax, esi
	pop	esi

; 625  : 	}

	ret	0
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ENDP ; std::_Traits_helper::move_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
___formal$ = 24						; size = 1
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z PROC ; std::_Traits_helper::copy_s<std::char_traits<char> >, COMDAT

; 597  : 		return _Traits::_Copy_s(_First1, _Size, _First2, _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memcpy_s
	add	esp, 16					; 00000010H
	mov	eax, esi
	pop	esi

; 598  : 	}

	ret	0
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ENDP ; std::_Traits_helper::copy_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T159627 = -12						; size = 12
$T159631 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 36   : 	{	// check for integer overflow

	sub	esp, 12					; 0000000cH
	push	esi

; 37   : 	if (_Count <= 0)

	mov	esi, DWORD PTR __Count$[esp+12]
	test	esi, esi
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	esi, esi
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	cmp	DWORD PTR ?RenNew@@3P6APAXK@ZA, 0	; RenNew
	jne	SHORT $LN8@Allocate
	call	?InitEngine@@YAXXZ			; InitEngine
$LN8@Allocate:
	push	esi
	call	DWORD PTR ?RenNew@@3P6APAXK@ZA		; RenNew
	add	esp, 4
	pop	esi

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	esi
	cmp	eax, 1
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T159631[esp+12]
	push	eax
	lea	ecx, DWORD PTR $T159627[esp+20]
	mov	DWORD PTR $T159631[esp+16], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T159627[esp+20]
	push	ecx
	mov	DWORD PTR $T159627[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@Allocate:
$LN11@Allocate:
	int	3
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z PROC ; std::_Traits_helper::move_s<std::char_traits<char> >, COMDAT

; 616  : 		return move_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
	mov	eax, esi
	pop	esi

; 617  : 	}

	ret	0
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ENDP ; std::_Traits_helper::move_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z PROC ; std::_Traits_helper::copy_s<std::char_traits<char> >, COMDAT

; 589  : 		return copy_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memcpy_s
	add	esp, 16					; 00000010H
	mov	eax, esi
	pop	esi

; 590  : 	}

	ret	0
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ENDP ; std::_Traits_helper::copy_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2114 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	mov	eax, DWORD PTR __Newsize$[esp-4]
	mov	DWORD PTR [ecx+20], eax
	jb	SHORT $LN5@Eos
	mov	ecx, DWORD PTR [ecx+4]
	mov	BYTE PTR [ecx+eax], 0

; 2115 : 		}

	ret	4

; 2114 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

$LN5@Eos:
	mov	BYTE PTR [ecx+eax+4], 0

; 2115 : 		}

	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
tv130 = 8						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1262 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebx

; 1263 : 		if (_Mysize < _Off)

	mov	ebx, DWORD PTR __Off$[esp]
	push	esi
	mov	esi, ecx
	push	edi
	cmp	DWORD PTR [esi+20], ebx
	jae	SHORT $LN3@erase

; 1264 : 			_String_base::_Xran();	// _Off off end

	call	?_Xran@_String_base@std@@SAXXZ		; std::_String_base::_Xran
$LN3@erase:

; 1265 : 		if (_Mysize - _Off < _Count)

	mov	eax, DWORD PTR [esi+20]
	mov	edi, DWORD PTR __Count$[esp+8]
	sub	eax, ebx
	cmp	eax, edi
	jae	SHORT $LN2@erase

; 1266 : 			_Count = _Mysize - _Off;	// trim _Count

	mov	edi, eax
$LN2@erase:

; 1267 : 		if (0 < _Count)

	test	edi, edi
	jbe	SHORT $LN30@erase

; 1268 : 			{	// move elements down
; 1269 : 			_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off, _Myptr() + _Off + _Count,
; 1270 : 				_Mysize - _Off - _Count);

	mov	ecx, DWORD PTR [esi+24]
	push	ebp
	lea	ebp, DWORD PTR [esi+4]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN8@erase
	mov	edx, DWORD PTR [ebp]
	mov	DWORD PTR tv130[esp+12], edx
	jmp	SHORT $LN9@erase
$LN8@erase:
	mov	DWORD PTR tv130[esp+12], ebp
$LN9@erase:
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN12@erase
	mov	edx, DWORD PTR [ebp]
	jmp	SHORT $LN13@erase
$LN12@erase:
	mov	edx, ebp
$LN13@erase:
	sub	eax, edi
	push	eax
	mov	eax, DWORD PTR tv130[esp+16]
	add	eax, ebx
	add	eax, edi
	push	eax
	sub	ecx, ebx
	push	ecx
	add	edx, ebx
	push	edx
	call	_memmove_s

; 1271 : 			size_type _Newsize = _Mysize - _Count;

	mov	eax, DWORD PTR [esi+20]
	sub	eax, edi
	add	esp, 16					; 00000010H

; 1272 : 			_Eos(_Newsize);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], eax
	jb	SHORT $LN26@erase
	mov	ebp, DWORD PTR [ebp]
$LN26@erase:
	mov	BYTE PTR [eax+ebp], 0
	pop	ebp
$LN30@erase:
	pop	edi

; 1273 : 			}
; 1274 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1275 : 		}

	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2149 : 		if (!_Built)

	cmp	BYTE PTR __Built$[esp-4], 0
	push	esi
	push	edi
	mov	edi, DWORD PTR __Newsize$[esp+4]
	mov	esi, ecx
	je	SHORT $LN17@Tidy@4

; 2150 : 			;
; 2151 : 		else if (_BUF_SIZE <= _Myres)

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN17@Tidy@4

; 2152 : 			{	// copy any leftovers to small buffer and deallocate
; 2153 : 			_Elem *_Ptr = _Bx._Ptr;

	lea	eax, DWORD PTR [esi+4]
	push	ebx
	mov	ebx, DWORD PTR [eax]

; 2154 : 			if (0 < _Newsize)

	test	edi, edi
	jbe	SHORT $LN13@Tidy@4

; 2155 : 				_Traits_helper::copy_s<_Traits>(_Bx._Buf, _BUF_SIZE, _Ptr, _Newsize);

	push	edi
	push	ebx
	push	16					; 00000010H
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H
$LN13@Tidy@4:

; 2156 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

	push	ebx
	call	DWORD PTR ?RenDelete@@3P6AXPAX@ZA	; RenDelete
	add	esp, 4
	pop	ebx
$LN17@Tidy@4:

; 2157 : 			}
; 2158 : 		_Myres = _BUF_SIZE - 1;
; 2159 : 		_Eos(_Newsize);

	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	BYTE PTR [esi+edi+4], 0
	pop	edi
	pop	esi

; 2160 : 		}

	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 905  : 		{	// destroy the string

	push	esi
	mov	esi, ecx

; 906  : 		_Tidy(true);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN19@basic_stri
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	DWORD PTR ?RenDelete@@3P6AXPAX@ZA	; RenDelete
	add	esp, 4
$LN19@basic_stri:
	xor	eax, eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], eax
	mov	BYTE PTR [esi+4], al
	pop	esi

; 907  : 		}

	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@13
	push	esi
	call	DWORD PTR ?RenDelete@@3P6AXPAX@ZA	; RenDelete
	add	esp, 4
$LN8@scalar@13:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$1
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$0
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$5
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2083 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH

; 2084 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	ebx
	push	esi
	mov	esi, eax
	push	edi
	or	esi, 15					; 0000000fH
	mov	edi, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], edi

; 2085 : 		if (max_size() < _Newres)

	cmp	esi, -2					; fffffffeH
	jbe	SHORT $LN6@Copy

; 2086 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	esi, eax

; 2087 : 		else if (_Newres / 3 < _Myres / 2

	jmp	SHORT $LN4@Copy
$LN6@Copy:

; 2088 : 			&& _Myres <= max_size() - _Myres / 2)

	mov	ebx, DWORD PTR [edi+24]
	mov	eax, -1431655765			; aaaaaaabH
	mul	esi
	mov	ecx, ebx
	shr	ecx, 1
	shr	edx, 1
	cmp	edx, ecx
	jae	SHORT $LN4@Copy
	mov	eax, -2					; fffffffeH
	sub	eax, ecx
	cmp	ebx, eax
	ja	SHORT $LN4@Copy

; 2089 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

	lea	esi, DWORD PTR [ecx+ebx]
$LN4@Copy:

; 2090 : 		_Elem *_Ptr = 0;
; 2091 : 
; 2092 : 		_TRY_BEGIN
; 2093 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	lea	ecx, DWORD PTR [esi+1]
	push	0
	push	ecx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8
	mov	DWORD PTR __Ptr$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN16@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$0:

; 2094 : 		_CATCH_ALL
; 2095 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Newres$[ebp], eax

; 2096 : 			_TRY_BEGIN
; 2097 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	inc	eax
	push	0
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	mov	DWORD PTR __Ptr$[ebp], eax
	add	esp, 8

; 2101 : 			_CATCH_END
; 2102 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 1
	mov	eax, $LN110@Copy
	ret	0
$LN110@Copy:
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR __Newres$[ebp]
$LN16@Copy:

; 2103 : 
; 2104 : 		if (0 < _Oldlen)

	mov	ebx, DWORD PTR __Oldlen$[ebp]
	test	ebx, ebx
	jbe	SHORT $LN73@Copy

; 2105 : 			_Traits_helper::copy_s<_Traits>(_Ptr, _Newres + 1, _Myptr(), _Oldlen);	// copy existing elements

	cmp	DWORD PTR [edi+24], 16			; 00000010H
	jb	SHORT $LN65@Copy
	mov	eax, DWORD PTR [edi+4]
	jmp	SHORT $LN66@Copy
$LN65@Copy:
	lea	eax, DWORD PTR [edi+4]
$LN66@Copy:
	push	ebx
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	lea	edx, DWORD PTR [esi+1]
	push	edx
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H
$LN73@Copy:

; 2106 : 		_Tidy(true);

	cmp	DWORD PTR [edi+24], 16			; 00000010H
	jb	SHORT $LN91@Copy
	mov	ecx, DWORD PTR [edi+4]
	push	ecx
	call	DWORD PTR ?RenDelete@@3P6AXPAX@ZA	; RenDelete
	add	esp, 4
$LN91@Copy:

; 2107 : 		_Bx._Ptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edi+4]
	mov	BYTE PTR [eax], 0
	mov	DWORD PTR [eax], ecx

; 2108 : 		_Myres = _Newres;

	mov	DWORD PTR [edi+24], esi

; 2109 : 		_Eos(_Oldlen);

	mov	DWORD PTR [edi+20], ebx
	cmp	esi, 16					; 00000010H
	jb	SHORT $LN105@Copy
	mov	eax, ecx
$LN105@Copy:

; 2110 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	BYTE PTR [eax+ebx], 0
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$1:

; 2098 : 			_CATCH_ALL
; 2099 : 			_Tidy(true);	// failed again, discard storage and reraise

	mov	esi, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN53@Copy
	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	DWORD PTR ?RenDelete@@3P6AXPAX@ZA	; RenDelete
	add	esp, 4
$LN53@Copy:

; 2100 : 			_RERAISE;

	push	0
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	push	0
	mov	BYTE PTR [esi+4], 0
	call	__CxxThrowException@8
$LN114@Copy:
$LN113@Copy:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtpy
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2119 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebx

; 2120 : 			if (max_size() < _Newsize)

	mov	ebx, DWORD PTR __Newsize$[esp]
	push	esi
	mov	esi, ecx
	cmp	ebx, -2					; fffffffeH
	jbe	SHORT $LN6@Grow

; 2121 : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN6@Grow:

; 2122 : 		if (_Myres < _Newsize)

	mov	eax, DWORD PTR [esi+24]
	cmp	eax, ebx
	jae	SHORT $LN5@Grow

; 2123 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

	mov	eax, DWORD PTR [esi+20]
	push	eax
	push	ebx
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2129 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	cmp	ecx, ebx
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 2130 : 		}

	ret	8
$LN5@Grow:

; 2124 : 		else if (_Trim && _Newsize < _BUF_SIZE)

	cmp	BYTE PTR __Trim$[esp+4], 0
	je	SHORT $LN3@Grow
	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN3@Grow
	push	edi

; 2125 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2126 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

	mov	edi, DWORD PTR [esi+20]
	cmp	ebx, edi
	jae	SHORT $LN9@Grow
	mov	edi, ebx
$LN9@Grow:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN35@Grow
	lea	eax, DWORD PTR [esi+4]
	push	ebp
	mov	ebp, DWORD PTR [eax]
	test	edi, edi
	jbe	SHORT $LN31@Grow
	push	edi
	push	ebp
	push	16					; 00000010H
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H
$LN31@Grow:
	push	ebp
	call	DWORD PTR ?RenDelete@@3P6AXPAX@ZA	; RenDelete
	add	esp, 4
	pop	ebp
$LN35@Grow:
	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH

; 2129 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	mov	BYTE PTR [esi+edi+4], 0
	cmp	ecx, ebx
	pop	edi
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 2130 : 		}

	ret	8
$LN3@Grow:

; 2127 : 		else if (_Newsize == 0)

	test	ebx, ebx
	jne	SHORT $LN51@Grow

; 2128 : 			_Eos(0);	// new size is zero, just null terminate

	mov	DWORD PTR [esi+20], ebx
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN49@Grow
	mov	esi, DWORD PTR [esi+4]

; 2129 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	cmp	ecx, ebx
	mov	BYTE PTR [esi], bl
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 2130 : 		}

	ret	8

; 2128 : 			_Eos(0);	// new size is zero, just null terminate

$LN49@Grow:
	add	esi, 4
	mov	BYTE PTR [esi], 0
$LN51@Grow:

; 2129 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	cmp	ecx, ebx
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 2130 : 		}

	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1046 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebx

; 1047 : 		if (_Right.size() < _Roff)

	mov	ebx, DWORD PTR __Right$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Roff$[esp+4]
	push	esi
	push	edi
	mov	esi, ecx
	cmp	DWORD PTR [ebx+20], ebp
	jae	SHORT $LN5@assign

; 1048 : 			_String_base::_Xran();	// _Roff off end

	call	?_Xran@_String_base@std@@SAXXZ		; std::_String_base::_Xran
$LN5@assign:

; 1049 : 		size_type _Num = _Right.size() - _Roff;

	mov	edi, DWORD PTR [ebx+20]

; 1050 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[esp+12]
	sub	edi, ebp
	cmp	eax, edi
	jae	SHORT $LN4@assign

; 1051 : 			_Num = _Count;	// trim _Num to size

	mov	edi, eax
$LN4@assign:

; 1052 : 
; 1053 : 		if (this == &_Right)

	cmp	esi, ebx
	jne	SHORT $LN3@assign

; 1054 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	push	-1
	add	edi, ebp
	push	edi
	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	push	ebp
	push	0
	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 1059 : 			}
; 1060 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1061 : 		}

	ret	12					; 0000000cH
$LN3@assign:

; 1055 : 		else if (_Grow(_Num))

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN17@assign
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN17@assign:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	jae	SHORT $LN16@assign
	mov	eax, DWORD PTR [esi+20]
	push	eax
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
$LN89@assign:
	jbe	SHORT $LN88@assign

; 1056 : 			{	// make room and assign new stuff
; 1057 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr() + _Roff, _Num);

	cmp	DWORD PTR [ebx+24], 16			; 00000010H
	jb	SHORT $LN66@assign
	mov	edx, DWORD PTR [ebx+4]
	jmp	SHORT $LN67@assign

; 1055 : 		else if (_Grow(_Num))

$LN16@assign:
	test	edi, edi
	jne	SHORT $LN89@assign
	mov	DWORD PTR [esi+20], edi
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN60@assign
	mov	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 1059 : 			}
; 1060 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1061 : 		}

	ret	12					; 0000000cH

; 1055 : 		else if (_Grow(_Num))

$LN60@assign:
	lea	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 1059 : 			}
; 1060 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1061 : 		}

	ret	12					; 0000000cH

; 1056 : 			{	// make room and assign new stuff
; 1057 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr() + _Roff, _Num);

$LN66@assign:
	lea	edx, DWORD PTR [ebx+4]
$LN67@assign:
	mov	ecx, DWORD PTR [esi+24]
	lea	ebx, DWORD PTR [esi+4]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN70@assign
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN71@assign
$LN70@assign:
	mov	eax, ebx
$LN71@assign:
	push	edi
	add	edx, ebp
	push	edx
	push	ecx
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 1058 : 			_Eos(_Num);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN84@assign
	mov	ebx, DWORD PTR [ebx]
$LN84@assign:
	mov	BYTE PTR [ebx+edi], 0
$LN88@assign:
	pop	edi

; 1059 : 			}
; 1060 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1061 : 		}

	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 721  : 		{	// construct by copying _Right

	push	esi

; 722  : 		_Tidy();

	xor	eax, eax
	mov	esi, ecx

; 723  : 		assign(_Right, 0, npos);

	push	-1
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	push	eax
	mov	BYTE PTR [esi+4], al
	mov	eax, DWORD PTR __Right$[esp+8]
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 724  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1064 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp

; 1065 : 
; 1066 :  #if _HAS_ITERATOR_DEBUGGING
; 1067 : 		if (_Count != 0)
; 1068 : 			_DEBUG_POINTER(_Ptr);
; 1069 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1070 : 
; 1071 : 		if (_Inside(_Ptr))

	mov	ebp, DWORD PTR __Ptr$[esp]
	push	esi
	push	edi
	mov	esi, ecx
	test	ebp, ebp
	je	SHORT $LN95@assign@3
	mov	edx, DWORD PTR [esi+24]
	lea	eax, DWORD PTR [esi+4]
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN12@assign@3
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN13@assign@3
$LN12@assign@3:
	mov	ecx, eax
$LN13@assign@3:
	cmp	ebp, ecx
	jb	SHORT $LN95@assign@3
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN16@assign@3
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN17@assign@3
$LN16@assign@3:
	mov	ecx, eax
$LN17@assign@3:
	mov	edi, DWORD PTR [esi+20]
	add	edi, ecx
	cmp	edi, ebp
	jbe	SHORT $LN95@assign@3

; 1072 : 			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring

	cmp	edx, 16					; 00000010H
	jb	SHORT $LN20@assign@3
	mov	eax, DWORD PTR [eax]
$LN20@assign@3:
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	ecx
	sub	ebp, eax
	push	ebp
	push	esi
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi
	pop	ebp

; 1080 : 		}

	ret	8
$LN95@assign@3:

; 1073 : 
; 1074 : 		if (_Grow(_Count))

	mov	edi, DWORD PTR __Count$[esp+8]
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN27@assign@3
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN27@assign@3:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	jae	SHORT $LN26@assign@3
	mov	edx, DWORD PTR [esi+20]
	push	edx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
$LN96@assign@3:
	jbe	SHORT $LN92@assign@3

; 1075 : 			{	// make room and assign new stuff
; 1076 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Count);

	mov	ecx, DWORD PTR [esi+24]
	push	ebx
	lea	ebx, DWORD PTR [esi+4]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN76@assign@3
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN77@assign@3

; 1073 : 
; 1074 : 		if (_Grow(_Count))

$LN26@assign@3:
	test	edi, edi
	jne	SHORT $LN96@assign@3
	mov	DWORD PTR [esi+20], edi
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN70@assign@3
	mov	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 1078 : 			}
; 1079 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 1080 : 		}

	ret	8

; 1073 : 
; 1074 : 		if (_Grow(_Count))

$LN70@assign@3:
	lea	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 1078 : 			}
; 1079 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 1080 : 		}

	ret	8

; 1075 : 			{	// make room and assign new stuff
; 1076 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Count);

$LN76@assign@3:
	mov	eax, ebx
$LN77@assign@3:
	push	edi
	push	ebp
	push	ecx
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 1077 : 			_Eos(_Count);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN90@assign@3
	mov	ebx, DWORD PTR [ebx]
$LN90@assign@3:
	mov	BYTE PTR [ebx+edi], 0
	pop	ebx
$LN92@assign@3:
	pop	edi

; 1078 : 			}
; 1079 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 1080 : 		}

	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1083 : 		{	// assign [_Ptr, <null>)

	push	esi

; 1084 : 		_DEBUG_POINTER(_Ptr);
; 1085 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	esi, DWORD PTR __Ptr$[esp]
	mov	eax, esi
	push	edi
	lea	edi, DWORD PTR [eax+1]
	npad	5
$LL5@assign@4:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL5@assign@4
	sub	eax, edi
	push	eax
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi

; 1086 : 		}

	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 652  : 		_Tidy();
; 653  : 		assign(_Ptr);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	push	esi
	mov	esi, ecx
	mov	eax, edx
	push	edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	mov	BYTE PTR [esi+4], 0
	lea	edi, DWORD PTR [eax+1]
	npad	1
$LL39@basic_stri@4:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL39@basic_stri@4
	sub	eax, edi
	push	eax
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi

; 654  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
END
